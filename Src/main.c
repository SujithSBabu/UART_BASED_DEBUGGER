/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "gpio.h"
#include "uart.h"
#include "get_register_data.h"
#include "memory_dump.h"
#include "stm32f407_xx_MemMap.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*SW delay*/
void sw_delay()
{
	for(uint32_t i =0;i< 500000;i++);
}

int main(void)
{
	extern System_State current_state;
	USART_RegDef_Struct* pusart = USART2;

	char string_array[] = "Hi,Sujith";

	gpioA_init();//initiaizing call for gpioa and usart2

    /* Loop forever */
	while(1)
	{

		/* state machine to handle system state and debugging commands*/
        if(current_state == SYSTEM_HALTED)
        {
        	uint8_t debugInfo_sent = 0;

        	__disable_irq();
        	pusart->USART_CR1 &= ~(1<<5);//disabling RXNEIE in USART2 CR1 to avoid race condition
        	usart_send_string(pusart, "System halted\r\n");

        	while(current_state == SYSTEM_HALTED)
        	{

                	uint32_t msp_data     = get_MSP_data();
					uint32_t psp_data     = get_PSP_data();
					uint32_t control_data = get_CONTROL_data();

                    if(!debugInfo_sent)
                    {
                    	usart_send_string(pusart, "*****Debug Commands:*****\r\n");
                    	usart_send_string(pusart, "> = Resume\r\n");
                    	usart_send_string(pusart, "m = MSP register data\r\n");
                        usart_send_string(pusart, "p = PSP register data\r\n");
                    	usart_send_string(pusart, "c = CONTROL register data\r\n");
                    	usart_send_string(pusart, "Memory Dump:\r\n1 = Memory Dump of first 16 addresses of SRAM1"
                    					  "\r\n2 = Memory Dump of GPIOA registers"
                    					  "\r\n3 = Memory Dump of USART2 registers\r\n");
                    	debugInfo_sent = 1;
                    }

                /*
                 * Polling to read USART2 SR ,
                 * as when system is halted interrupt handling will be disabled,so to resume back
                 * there should be polling method to read input from user
                 */
                if(pusart->USART_SR & (1 << 5))
				{
					char ch = pusart->USART_DR;
					if(ch == '>')
					{
						__enable_irq();
						pusart->USART_CR1 |= (1<<5);//enabling RXNEIE in USART2 CR1
					}
					else if(ch == 'm')
					{
						/*MSP data*/
						usart_send_string(pusart, "MSP_REG_data:");
						usart_send_hex(pusart, msp_data);
						usart_send_string(pusart, "\r\n");
					}
					else if(ch == 'p')
					{
						/*PSP data*/
						usart_send_string(pusart, "PSP_REG_data:");
						usart_send_hex(pusart, psp_data);
						usart_send_string(pusart, "\r\n");
					}
					else if(ch == 'c')
					{
						/*Control register data*/
						usart_send_string(pusart, "CONTROL_REG_data:");
						usart_send_hex(pusart, control_data);
						usart_send_string(pusart, "\r\n");
					}
					else if(ch == '1')
					{
						/*Memory Dump*/
						get_memory_dump(1);
						usart_send_string(pusart, "\r\n");
					}
					else if(ch == '2')
					{
						/*Memory Dump*/
						get_memory_dump(2);
						usart_send_string(pusart, "\r\n");
					}
					else if(ch == '3')
					{
						/*Memory Dump*/
						get_memory_dump(3);
						usart_send_string(pusart, "\r\n");
					}
				}
        	}

        }

        usart_send_string(pusart, "System running\r\n");
        sw_delay();

	}
}
